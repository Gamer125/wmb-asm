#include "common.h"

int /*__attribute__ ((long_call))*/ main(void)
{
	void (*resetArm9)(void) = (void*)*((u32*)0x022ffffc);
	if(resetArm9)resetArm9();
	tNDSHeader *hdr = (tNDSHeader*)0x02300000;
	int hdrlen = 0x160;
	void (*func_ptr)(void);
	//void (*dc_flushall)(void);
	memcpy_arm9((void*)hdr->arm9destination, (void*)(0x02300000 + hdr->arm9romOffset), hdr->arm9binarySize);
	//if(DSi_mode && *((vu32*)((int)NDSHEADER + 0x1cc)))memcpy_arm9((void*)*((vu32*)((int)0x02300000 + 0x1c8)), (void*)(0x02300000 + *((vu32*)((int)0x02300000 + 0x1c0))), *((vu32*)((int)0x02300000 + 0x1cc)));//Load the 9i bin when used.
	//dc_flushall = &DC_FlushAll;
	//dc_flushall();
	DC_FlushAll();
	IC_InvalidateAll();
	IPC_SendSync(0x0);

	//if(DSi_mode)hdrlen = 0x200;
	memcpy_arm9((void*)NDSHEADER, (void*)0x02300000, hdrlen);//We assume that Arm7 will be executing our bootstub by the time we're overwriting arm7executeAddress when we're copying the header to the NDSHEADER address. With DS this works fine, hopefully this works fine with DSi without adding sanity checks etc.
	BOOTFLAG = 1;
	//while(BOOTFLAG!=2);
	while(REG_VCOUNT!=192);//Sync with Arm7 before jumping to the bin.
	while(REG_VCOUNT==192);

	func_ptr = (void*)NDSHEADER->arm9executeAddress;
	func_ptr();
	while(1);//Should never happen.
	return 0;
}

void inline memcpy_arm9(void* a, void* b, size_t len)
{
	vu32 *bufa = (vu32*)a;
	vu32 *bufb = (vu32*)b;
	while(len>0)
	{
		*bufa = *bufb;
		bufa++;
		bufb++;
		len-=4;
	}
}

